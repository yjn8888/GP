工厂模式
简单工厂模式（也叫 静态工厂模式）
很少单独使用，根据参数（枚举、字符串、class、等）判断创建哪种对象
适用场景
产品创建逻辑稳定，不能轻易修改
产品类型数量固定有限，只能支持一类产品的创建
优点：
逻辑简单，能快速实现
易于理解
符合迪米特法则、依赖倒置、里氏替换、单一职能原则
缺点：
违反开闭原则，因为不支持扩展，
所有创建逻辑可能都在一个方法内，每次增加产品都要修改逻辑
要求用户要知道产品创建的一定细节，有可能让用户输入参数错误，
经典案例
JDK : Calendar.createCalendar() 根据时区、或者默认返回一个对应Calendar对象
Slf4J: LoggerFactory.getLogger(Class) 根据对应的类穿件一个logger对象
工厂方法
需要定义一个工厂方法接口（或者抽象类把一些公共的逻辑抽象）一种对象产品都被特定的工厂类生产，特定工厂类需要客户端自己创建
适用场景
产品创建逻辑复杂，且大量重复代码，可以抽象到公共的父类中
客户端不需要了解产品的创建细节，只需要知道我要的这个产品的工厂即可，不需要传参
优点：
符合开闭原则、单一职能、里氏替换、依赖倒置原则，易于扩展
缺点
如果增加一个产品，需要创建一个对应的工厂，增加开发量、代码结构的复杂度
逻辑抽象程度升高，不易于理解
经典案例
Slf4J: LoggerFactory.getLogger(Class) 内部实现其实是线创建一个ILoggerFactory工厂类的实现类调用他的getLogger()方法
抽象工厂
编写抽象工厂基类，定义多个抽象方法，每个抽象方法对应生产一个特定产品，可以和以上两种配合使用
适用场景
客户端不依赖于产品类的实例如何创建、实现的细节
强调一个系列相关产品（同一个产品族）一起被创建，存在大量重复代码
提供了一个产品类的库，所有产品以同样的接口出现，从而使客户端不依赖于具体实现
优点
符合开闭原则、依赖倒置、历史替换、单一职能原则，易于扩展产品族
缺点
因为产品族每增加一类产品需要修改接口并修改所有的抽象工厂的子类，这样对于开闭原则支持减弱
违背接口隔离原则，产品族里的所有类别都在一个接口中，如果存在一个产品族没有某几类产品这样这些方法冗余并且有可能被用户错误调用，产生问题
经典案例
spring framework 中的BeanFactory、DeafultListableFactory等等 不过spring结合了工厂方法+抽象工厂的模式，做到了接口隔离，这样实现类可自由组合集成各个接口实现不同的功能